/// Emulator for the MOS 6502
///
/// This does not include support for Binary Coded Decimal, which was omitted
/// on the 2A03 variant used on the NES and Famicom. Support for BCD may be
/// added later.
use std::fmt;
use std::cell::{RefCell};
use std::rc::{Rc};
use std::num::Wrapping;

use crate::databus::Bus;
use self::structs::{AddressingMode, Instruction, Status};

fn bytes_to_addr(lo: u8, hi: u8) -> u16 {
    (u16::from(lo) << 8) + u16::from(hi)
}

pub struct Cpu6502<T: Bus> {
    //region CPU Registers
    /// The Accumulator register
    acc: u8,

    /// X index register
    x: u8,

    /// Y index register
    y: u8,

    /// The stack pointer
    ///
    /// # Note
    ///
    /// This register is a pointer to a location in memory on the first page
    /// ($01XX) of memory. The 6502 uses a bottom-up stack, so the 'first'
    /// location on the stack is `$01FF` and the 'last' is `$0100`.
    ///
    /// Stack _overflow_ occurs when the stack pointer decreases all the way to
    /// $00 and wraps around to $FF (the beginning). _Underflow_ occurs the
    /// other way around, from $FF to $00.
    stack: u8,

    /// The program counter
    ///
    /// # Note
    ///
    /// This is incremented by the emulator after executing each instruction,
    /// and refers to the address in memory of the next instruction
    pc: u16,

    /// The instruction being executed.
    ///
    /// # Note
    ///
    /// Instructions consist of an opcode, having 1 byte, and an optional
    /// operand having 1 or 2 bytes (depending on the instruction and addressing
    /// mode).
    ///
    /// The last 8 bits of this register are unused.
    instruction: u32,

    /// The program status register.
    status: Status,
    //endregion

    //region internal state
    // The variables below are used as internal state by the emulator, and
    // are unrelated to the 6502.
    /// The number of cycles to wait before executing the next instruction.
    ///
    /// # Note
    ///
    /// On the 6502, most instructions took longer than 1 clock cycle. Some
    /// took quite a few more, as the instruction had to read off operands
    /// from memory. This is a counter to simulate that- if not zero,
    /// `clock` will simply decrement this and continue.
    cycles: u8,

    /// The total number of cycles that this CPU has ran
    ///
    /// # Note
    ///
    /// This is allowed to overflow, as it's only used for debugging and test
    /// comparison. It is not a part of core emulation.
    tot_cycles: u32,

    /// The resolved address of the instruction
    addr: u16,

    /// The addressing mode of the opcode being executed
    addr_mode: AddressingMode,

    /// The opcode being executed
    instr: Instruction,

    /// A reference to the address bus.
    ///
    /// # Note
    ///
    /// Busses are typically owned by a higher level struct, and should have
    /// lifetimes equivalent to or exceeding the CPU lifetime.
    ///
    /// The bus should be set before executing instructions, and should not be
    /// set more than once- this will result in undefined behavior.
    bus: Rc<RefCell<T>>,

    /// Whether an interrupt is pending
    interrupt_pending: bool,
    /// Whether that interrupt was generated by an NMI (false) or IRQ (true)
    maskable_interrupt: bool,
    //endregion

}

impl<T: Bus> Cpu6502<T> {
    pub fn tick(&mut self) -> bool {
        if self.cycles > 0 {
            self.tot_cycles += 1;
            self.cycles -= 1;
            return false;
        }
        true
    }

    pub fn exec(&mut self) {
        self.run_interrupt();
        self.load_opcode();
        self.decode_opcode(self.instruction);
        self.addr = self.get_addr(self.instruction);
        self.exec_instr();
    }

    pub fn debug(&mut self) -> String {
        let old_pc = self.pc;
        self.run_interrupt();
        self.load_opcode();
        self.decode_opcode(self.instruction);
        self.addr = self.get_addr(self.instruction);
        let new_pc = self.pc;
        self.pc = old_pc;
        let debug_str = format!("{}", self);
        self.pc = new_pc;
        self.exec_instr();
        debug_str
    }

    pub fn reset(&mut self) {
        self.stack -= 3;
        self.status |= Status::IRQ_DISABLE;
        self.pc = 0xFFFC;
    }

    pub fn set_flag(&mut self, flag: Status) {
        self.status |= flag;
    }

    pub fn clear_flag(&mut self, flag: Status) {
        self.status &= !flag;
    }

    pub fn jmp(&mut self, addr: u16) {
        self.pc = addr;
    }

    pub fn trigger_nmi(&mut self) {
        self.interrupt_pending = true;
        self.maskable_interrupt = false;
    }

    pub fn trigger_irq(&mut self) {
        if self.status.contains(Status::IRQ_DISABLE) {
            return; // interrupt ignored
        }
        self.interrupt_pending = true;
        self.maskable_interrupt = true;
    }

    fn load_opcode(&mut self) {
        let bus = self.bus.borrow();
        let opcode = bus.read(self.pc);
        let operand1 = bus.read((Wrapping(self.pc) + Wrapping(1)).0);
        let operand2 = bus.read((Wrapping(self.pc) + Wrapping(2)).0);
        self.instruction = u32::from(opcode) + (u32::from(operand1) << 8) + (u32::from(operand2) << 16)
    }

    fn adv_pc(&mut self, inc: u16) {
        self.pc = (Wrapping(self.pc) + Wrapping(inc)).0;
    }

    /// Decodes an instruction into it's opcode and operand.
    ///
    /// # Notes
    ///
    /// Uses an algorithm described here: http://nparker.llx.com/a2/opcodes.html
    ///
    /// This may have errors or omissions for the NES 2A03, as that CPU's
    /// undocumented opcodes may be different in important ways.
    fn decode_opcode(&mut self, instruction: u32) {
        let ops = instruction.to_le_bytes();

        // Instructions are structured as:
        //   0......7 8..........15 16.........23
        //   aaabbbcc <lo operand?> <hi operand?>
        //
        // The `cc` bits differentiate between a few subtables. The `aaa` bits
        // determine the opcode, and the `bbb` bits determine the addrssing
        // mode. `cc` never takes the form `11`.

        // Before we go any further, there's a few instructions that are better
        // to special case.
        match ops[0] {
            0x00 => {
                self.instr = Instruction::BRK;
                self.addr_mode = AddressingMode::Impl;
                return;
            }
            0x20 => {
                self.instr = Instruction::JSR;
                self.addr_mode = AddressingMode::Abs;
                return;
            }
            0x6C => {
                self.instr = Instruction::JMP;
                self.addr_mode = AddressingMode::AbsInd;
                return;
            }
            0x40 => {
                self.instr = Instruction::RTI;
                self.addr_mode = AddressingMode::Impl;
                return;
            }
            0x60 => {
                self.instr = Instruction::RTS;
                self.addr_mode = AddressingMode::Impl;
                return;
            }
            0x8A => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::TXA;
                return;
            }
            0x9A => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::TXS;
                return;
            }
            0xAA => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::TAX;
                return;
            }
            0xBA => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::TSX;
                return;
            }
            0xCA => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::DEX;
                return;
            }
            0xEA => {
                self.addr_mode = AddressingMode::Impl;
                self.instr = Instruction::NOP;
                return;
            }
            _ => {}
        };

        let subtable = ops[0] & 0x3;
        let addr_mode = (ops[0] & 0x1c) >> 2;
        let opcode = (ops[0] & 0xe0) >> 5;

        match subtable {
            0b01 => {
                self.instr = match opcode {
                    0b000 => Instruction::ORA,
                    0b001 => Instruction::AND,
                    0b010 => Instruction::EOR,
                    0b011 => Instruction::ADC,
                    0b100 => Instruction::STA,
                    0b101 => Instruction::LDA,
                    0b110 => Instruction::CMP,
                    0b111 => Instruction::SBC,
                    _ => panic!("Invalid opcode"),
                };
                self.addr_mode = match addr_mode {
                    0b000 => AddressingMode::IndX,
                    0b001 => AddressingMode::ZP,
                    0b010 => AddressingMode::Imm,
                    0b011 => AddressingMode::Abs,
                    0b100 => AddressingMode::IndY,
                    0b101 => AddressingMode::ZPX,
                    0b110 => AddressingMode::AbsY,
                    0b111 => AddressingMode::AbsX,
                    _ => panic!("Invalid addressing mode"),
                };
            }
            0b10 => {
                self.instr = match opcode {
                    0b000 => Instruction::ASL,
                    0b001 => Instruction::ROL,
                    0b010 => Instruction::LSR,
                    0b011 => Instruction::ROR,
                    0b100 => Instruction::STX,
                    0b101 => Instruction::LDX,
                    0b110 => Instruction::DEC,
                    0b111 => Instruction::INC,
                    _ => panic!("Invalid opcode"),
                };
                // the STX and LDX instructions should target the Y index register instead
                let use_y = self.instr == Instruction::STX || self.instr == Instruction::LDX;
                self.addr_mode = match addr_mode {
                    0b000 => AddressingMode::Imm,
                    0b001 => AddressingMode::ZP,
                    0b010 => AddressingMode::Accum,
                    0b011 => AddressingMode::Abs,
                    // skip 0b100 (branch instr)
                    0b101 => {
                        if use_y {
                            AddressingMode::ZPY
                        } else {
                            AddressingMode::ZPX
                        }
                    }
                    // skip 0b110 (single byte instr)
                    0b111 => {
                        if use_y {
                            AddressingMode::AbsY
                        } else {
                            AddressingMode::AbsX
                        }
                    }
                    _ => panic!("Invalid addressing mode"),
                }
            }
            0b00 => {
                if ops[0] & 0x0F == 0x08 {
                    // this is a single byte instruction, and doesn't map to the AAABBBCC pattern
                    // handle it specially
                    self.addr_mode = AddressingMode::Impl;
                    self.instr = match ops[0] >> 4 {
                        0x0 => Instruction::PHP,
                        0x1 => Instruction::CLC,
                        0x2 => Instruction::PLP,
                        0x3 => Instruction::SEC,
                        0x4 => Instruction::PHA,
                        0x5 => Instruction::CLI,
                        0x6 => Instruction::PLA,
                        0x7 => Instruction::SEI,
                        0x8 => Instruction::DEY,
                        0x9 => Instruction::TYA,
                        0xA => Instruction::TAY,
                        0xB => Instruction::CLV,
                        0xC => Instruction::INY,
                        0xD => Instruction::CLD,
                        0xE => Instruction::INX,
                        0xF => Instruction::SED,
                        _ => panic!("Invalid instruction"),
                    };
                    return;
                }
                if addr_mode == 0b100 {
                    // these are branch instructions
                    self.addr_mode = AddressingMode::Rel;
                    self.instr = match opcode {
                        0b000 => Instruction::BPL,
                        0b001 => Instruction::BMI,
                        0b010 => Instruction::BVC,
                        0b011 => Instruction::BVS,
                        0b100 => Instruction::BCC,
                        0b101 => Instruction::BCS,
                        0b110 => Instruction::BNE,
                        0b111 => Instruction::BEQ,
                        _ => panic!("Invalid opcode"),
                    };
                    return;
                }
                self.instr = match opcode {
                    // skip 0b000 (branch instr)
                    0b001 => Instruction::BIT,
                    0b010 => Instruction::JMP,
                    0b011 => Instruction::JMP, // abs addressing
                    0b100 => Instruction::STY,
                    0b101 => Instruction::LDY,
                    0b110 => Instruction::CPY,
                    0b111 => Instruction::CPX,
                    _ => panic!("Invalid opcode"),
                };
                self.addr_mode = match addr_mode {
                    0b000 => AddressingMode::Imm,
                    0b001 => AddressingMode::ZP,
                    // skip 0b010
                    0b011 => AddressingMode::Abs,
                    // skip 0b100 (branch instr)
                    0b101 => AddressingMode::ZPX,
                    // skip 0b110
                    0b111 => AddressingMode::AbsX,
                    _ => panic!("Invalid addressing mode"),
                }
            }
            0b11 => {}
            _ => panic!("Invalid instruction"),
        }
    }

    /// Gets the address of the operand to read from.
    ///
    /// # Notes
    ///
    /// This sets the `cycles` to the average whole number of cycles any
    /// instruction with this addressing mode will have. Other instructions may
    /// need to add or subtract to compensate, refer to the 6502 datasheet for
    /// details:
    ///
    /// http://archive.6502.org/datasheets/mos_6501-6505_mpu_preliminary_aug_1975.pdf
    ///
    /// A note on the so-called "oops" cycle: The "oops" cycle occurs when an
    /// index instruction crosses a page boundary, as the CPU reads off the high
    /// byte first without checking for a carry-out. Some instructions (like all
    /// the store instructions) have some special-cased behavior that the 6502
    /// datasheet details. These depend on the instruction being executed, but
    /// this function is the best place to
    fn get_addr(&mut self, instruction: u32) -> u16 {
        let ops = instruction.to_le_bytes();
        // +2 cycles for instr + byte1 of op readout, minimum
        self.cycles += 2;
        // Advance the PC at _least_ 1 byte
        self.adv_pc(1);

        match self.addr_mode {
            AddressingMode::Abs => {
                self.adv_pc(2);
                bytes_to_addr(ops[2], ops[1])
            }
            AddressingMode::AbsInd => {
                let addr = bytes_to_addr(ops[2], ops[1]);
                self.adv_pc(2);
                let lo = self.read_bus(addr);
                let hi = self.read_bus(addr + 1);
                // TODO: JMP,AbsInd should get the right # of cycles
                self.cycles += 1;
                bytes_to_addr(hi, lo)
            }
            AddressingMode::AbsX => {
                let addr = bytes_to_addr(ops[2], ops[1]) + u16::from(self.x);
                self.adv_pc(2);
                if (u16::from(self.x) + u16::from(ops[1])) & 0x0100 == 0x0100 {
                    self.cycles += 1; // oops cycle
                }
                self.cycles += 3;
                addr
            }
            AddressingMode::AbsY => {
                let addr = bytes_to_addr(ops[2], ops[1]) + u16::from(self.y);
                self.adv_pc(2);
                if (u16::from(self.y) + u16::from(ops[1])) & 0x0100 == 0x0100 {
                    self.cycles += 1; // oops cycle
                }
                self.cycles += 3;
                addr
            }
            AddressingMode::Accum => {
                // TODO: Make addressing Optional?
                0x0000
            }
            AddressingMode::Imm => {
                self.adv_pc(1);
                0x0000
            }
            AddressingMode::Impl => 0x0000,
            AddressingMode::IndX => {
                self.adv_pc(1);
                let lo = self.read_bus(u16::from(ops[1] + self.x));
                let hi = self.read_bus(u16::from(ops[1] + self.x + 1));
                self.cycles += 2;
                bytes_to_addr(lo, hi)
            }
            AddressingMode::IndY => {
                self.adv_pc(1);
                let lo = self.read_bus(u16::from(ops[1]));
                // wrap cast to make sure Rust doesn't expand either op prematurely
                let hi = self.read_bus(u16::from((ops[1] + 1) as u8));
                self.cycles += 1;
                if (u16::from(self.y) + u16::from(ops[1])) & 0x0100 == 0x0100 {
                    self.cycles += 1; // oops cycle
                }
                bytes_to_addr(lo, hi) + u16::from(self.y)
            }
            AddressingMode::Rel => {
                self.adv_pc(1);
                self.pc + u16::from(ops[1])
            },
            AddressingMode::ZP => {
                self.adv_pc(1);
                bytes_to_addr(ops[1], 0)
            }
            AddressingMode::ZPX => {
                self.adv_pc(1);
                bytes_to_addr((Wrapping(ops[1]) + Wrapping(self.x)).0, 0)
            }
            AddressingMode::ZPY => {
                self.adv_pc(1);
                bytes_to_addr((Wrapping(ops[1]) + Wrapping(self.y)).0, 0)
            }
        }
    }

    /// Read a byte from the bus, adding one to the cycle time
    fn read_bus(&mut self, addr: u16) -> u8 {
        self.cycles += 1;
        let bus = self.bus.borrow();
        bus.read(addr)
    }

    /// Read the data at the resolved address
    fn read(&mut self) -> u8 {
        let ops = self.instruction.to_le_bytes();
        match self.addr_mode {
            AddressingMode::Imm => ops[1],
            AddressingMode::Accum => self.acc,
            _ => self.read_bus(self.addr)
        }
    }

    fn write(&mut self, data: u8) {
        self.cycles += 1;
        let mut bus = self.bus.borrow_mut();
        bus.write(self.addr, data);
    }

    fn push_stack(&mut self, data: u8) {
        let mut bus = self.bus.borrow_mut();
        let addr = bytes_to_addr(0x01, self.stack);
        bus.write(addr, data);
        self.cycles += 1;
        self.stack -= 1;
    }

    fn pop_stack(&mut self) -> u8 {
        self.stack += 1;
        let addr = bytes_to_addr(0x01, self.stack);
        self.read_bus(addr)
    }

    fn check_carry(&mut self, val: u16) {
        if val & 0x100 == 0x100 {
            // an overflow occured
            self.set_flag(Status::CARRY);
        } else {
            self.clear_flag(Status::CARRY);
        }
    }

    fn check_zero(&mut self, val: u8) {
        if val == 0 {
            self.set_flag(Status::ZERO);
        } else {
            self.clear_flag(Status::ZERO);
        }
    }

    fn check_overflow(&mut self, left: u8, right: u8) {
        let left = u16::from(left);
        let right = u16::from(right);
        let res = left + right;
        if ((left^res) & (right^res)) & 0x80 != 0 {
            self.set_flag(Status::OVERFLOW);
        } else {
            self.clear_flag(Status::OVERFLOW);
        }
    }

    fn check_negative(&mut self, op: u8) {
        if op & 0x80 != 0 {
            self.set_flag(Status::NEGATIVE);
        } else {
            self.clear_flag(Status::NEGATIVE);
        }
    }

    /// Execute the loaded instruction.
    ///
    /// Internally this uses a massive match pattern- TBD on whether this should
    /// be changed, but given that most of the instructions are self-contained
    /// and very short, I think it's not indefensible (plus it's easy).
    fn exec_instr(&mut self) {
        match self.instr {
            //region Arithmetic ops
            // ADC SBC
            Instruction::ADC => {
                if self.status.contains(Status::DECIMAL) {
                    eprintln!(" [WARN] This emulator doesn't support BCD, but the BCD flag is set");
                }
                let op = self.read();
                let val = Wrapping(u16::from(self.acc))
                    + Wrapping(u16::from(op))
                    + Wrapping(if self.status.contains(Status::CARRY) { 1 } else { 0 });
                self.check_carry(val.0);
                self.check_overflow(self.acc, op);
                self.acc = (0xFF & val.0) as u8;
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::SBC => {
                if self.status.contains(Status::DECIMAL) {
                    eprintln!(" [WARN] This emulator doesn't support BCD, but the BCD flag is set");
                }
                let op = self.read();
                let val = Wrapping(u16::from(self.acc))
                    - Wrapping(u16::from(op))
                    - Wrapping(if !self.status.contains(Status::CARRY) { 1 } else { 0 });
                self.check_carry(!val.0);
                self.check_overflow(self.acc, !op);
                self.acc = (0xFF & val.0) as u8;
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            //endregion

            //region Bitwise ops
            // AND BIT EOR ORA
            Instruction::AND => {
                self.acc &= self.read();
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::BIT => {
                let op = self.read();
                let res = self.acc & op;
                self.check_zero(res);
                self.status = Status::from_bits_truncate((self.status.bits() & 0x3F) | (0xC0 & op));
            }
            Instruction::EOR => {
                self.acc ^= self.read();
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::ORA => {
                self.acc |= self.read();
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            //endregion

            Instruction::ASL => {
                let op = self.read();
                let res = u16::from(op) << 1;
                self.check_carry(res);
                self.acc = (0xFF & res) as u8;
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }

            //region Branch instructions
            // BPL BMI BVC BVS BCC BCS BEQ BNE
            Instruction::BPL => {
                if self.status.contains(Status::NEGATIVE) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BMI => {
                if !self.status.contains(Status::NEGATIVE) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BVC => {
                if self.status.contains(Status::OVERFLOW) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BVS => {
                if !self.status.contains(Status::OVERFLOW) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BCC => {
                if self.status.contains(Status::CARRY) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BCS => {
                if !self.status.contains(Status::CARRY) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BEQ => {
                if !self.status.contains(Status::ZERO) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::BNE => {
                if self.status.contains(Status::ZERO) { return; }
                self.cycles += 1;
                self.pc = self.addr;
            }
            //endregion

            Instruction::BRK => {
                // TODO: Set interrupt
                self.set_flag(Status::BREAK);
                let status = self.status.bits() ^ 0x30;
                self.push_stack(status);
                let addr_bytes = self.pc.to_le_bytes();
                self.push_stack(addr_bytes[1]);
                self.push_stack(addr_bytes[0]);
                let addr_lo = self.read_bus(0xFFFE);
                let addr_hi = self.read_bus(0xFFFF);
                self.pc = bytes_to_addr(addr_lo, addr_hi);
            }

            //region Compare functions
            // CMP CPX CPY
            Instruction::CMP => {
                let data = self.read();
                let res = Wrapping(self.acc) - Wrapping(data);
                self.status.set(Status::CARRY, self.acc >= data);
                self.check_zero(res.0);
                self.check_negative(res.0);
            }
            Instruction::CPX => {
                let data = self.read();
                let res = Wrapping(self.x) - Wrapping(data);
                self.status.set(Status::CARRY, self.x >= data);
                self.check_zero(res.0);
                self.check_negative(res.0);
            }
            Instruction::CPY => {
                let data = self.read();
                let res = Wrapping(self.y) - Wrapping(data);
                self.status.set(Status::CARRY, self.y >= data);
                self.check_zero(res.0);
                self.check_negative(res.0);
            }
            // endregion

            //region Memory functions
            // DEC INC LSR ROL ROR
            Instruction::DEC => {
                let op = self.read() - 1;
                self.cycles += 1;
                self.write(op);
                self.check_zero(op);
                self.check_negative(op);
            }
            Instruction::INC => {
                let op = self.read() + 1;
                self.cycles += 1;
                self.write(op);
                self.check_zero(op);
                self.check_negative(op);
            }
            Instruction::LSR => {
                // I'm doing a bit of a trick here
                // If we look at the *high* byte, then functionally there's no
                // difference between (u16 << 7) and (u8 >> 1). But by casting
                // to u16 and doing it 'backwards', we preserve the lopped off
                // bit so that we can use it to set the carry bit
                let data = u16::from(self.read()) << 7;
                // we want the last bit for the carry -----v
                self.status.set(Status::CARRY, data & 0x00_80 == 0x00_80);
                // throw out the extra byte now that we're done with it
                let data = data.to_be_bytes()[0];
                self.check_zero(data);
                self.check_negative(data);
                // Finally, since this _could_ go to the accumulator, we need to
                // check for that addressing mode
                match self.addr_mode {
                    AddressingMode::Accum => self.acc = data,
                    _ => self.write(data)
                };
            }
            Instruction::ROL => {
                // See my notes on the LSR instruction, I do a similar trick
                // here (for similar reasons)
                let data = u16::from(self.read()) << 7
                    | if self.status.contains(Status::CARRY) { 0x80_00 } else { 0x0 };
                self.status.set(Status::CARRY, data & 0x00_80 == 0x00_80);
                let data = data.to_be_bytes()[0];
                self.check_zero(data);
                self.check_negative(data);
                // Even the caveat on addressing is the same
                match self.addr_mode {
                    AddressingMode::Accum => self.acc = data,
                    _ => self.write(data)
                };
            }
            Instruction::ROR => {
                let data = u16::from(self.read() << 1)
                    | if self.status.contains(Status::CARRY) { 0x01 } else { 0x00 };
                self.status.set(Status::CARRY, data & 0x01_00 == 0x01_00);
                let data: u8 = (data & 0xFF) as u8;
                self.check_zero(data);
                self.check_negative(data);
                match self.addr_mode {
                    AddressingMode::Accum => self.acc = data,
                    _ => self.write(data)
                };
            }
            //endregion

            //region Flag operations
            // CLC SEC CLI SEI CLV CLD SED
            Instruction::CLC => self.clear_flag(Status::CARRY),
            Instruction::SEC => self.set_flag(Status::CARRY),
            Instruction::CLI => self.clear_flag(Status::IRQ_DISABLE),
            Instruction::SEI => self.set_flag(Status::IRQ_DISABLE),
            Instruction::CLV => self.clear_flag(Status::OVERFLOW),
            Instruction::CLD => self.clear_flag(Status::DECIMAL),
            Instruction::SED => self.set_flag(Status::DECIMAL),
            //endregion

            //region Jumps
            // JMP JSR RTI RTS
            Instruction::JMP => {
                self.cycles += 1;
                self.pc = self.addr;
            }
            Instruction::JSR => {
                let addr_bytes = (self.pc).to_le_bytes();
                self.push_stack(addr_bytes[1]);
                self.push_stack(addr_bytes[0]);
                self.pc = self.addr;
                self.cycles += 2;
            }
            Instruction::RTI => {
                let flags = self.pop_stack();
                self.status = Status::from_bits_truncate(flags) & !(Status::UNUSED | Status::BREAK);
                let lo = self.pop_stack();
                let hi = self.pop_stack();
                self.pc = bytes_to_addr(hi, lo);
            }
            Instruction::RTS => {
                let lo = self.pop_stack();
                let hi = self.pop_stack();
                self.pc = bytes_to_addr(hi, lo);
                self.cycles += 2;
            }
            //endregion

            //region Loads
            Instruction::LDA => {
                self.acc = self.read();
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::LDX => {
                self.x = self.read();
                self.check_zero(self.x);
                self.check_negative(self.x);
            }
            Instruction::LDY => {
                self.y = self.read();
                self.check_zero(self.y);
                self.check_negative(self.y);
            }
            //endregion

            Instruction::NOP => {
                // no operation
            }

            //region Register instructions
            Instruction::TAX => {
                self.x = self.acc;
                self.check_zero(self.x);
                self.check_negative(self.x);
            }
            Instruction::TXA => {
                self.acc = self.x;
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::TAY => {
                self.y = self.acc;
                self.check_zero(self.y);
                self.check_negative(self.y);
            }
            Instruction::TYA => {
                self.acc = self.y;
                self.check_zero(self.acc);
                self.check_negative(self.acc);
            }
            Instruction::INX => {
                self.x = (Wrapping(self.x) + Wrapping(1)).0;
                self.check_zero(self.x);
                self.check_negative(self.x);
            }
            Instruction::DEX => {
                self.x = (Wrapping(self.x) - Wrapping(1)).0;
                self.check_zero(self.x);
                self.check_negative(self.x);
            }
            Instruction::INY => {
                self.y = (Wrapping(self.y) + Wrapping(1)).0;
                self.check_zero(self.y);
                self.check_negative(self.y);
            }
            Instruction::DEY => {
                self.y = (Wrapping(self.y) - Wrapping(1)).0;
                self.check_zero(self.y);
                self.check_negative(self.y);
            }
            //endregion

            //region Storage instruction
            Instruction::STA => {
                self.write(self.acc)
            }
            Instruction::STX => {
                self.write(self.x);
            }
            Instruction::STY => {
                self.write(self.y);
            }
            //endregion

            //region Stack instructions
            Instruction::TXS => {
                self.stack = self.x;
            }
            Instruction::TSX => {
                self.x = self.stack;
                self.check_zero(self.x);
                self.check_negative(self.x);
            }
            Instruction::PHA => {
                self.push_stack(self.acc);
            }
            Instruction::PLA => {
                self.acc = self.pop_stack();
                self.check_zero(self.acc);
                self.check_negative(self.acc);
                self.cycles += 1;
            }
            Instruction::PHP => {
                self.push_stack(self.status.bits() | 0x30)
            }
            Instruction::PLP => {
                self.status = Status::from_bits_truncate((self.pop_stack() & 0xEF) | 0x20);
                self.cycles += 1;
            }
            //endregion
        }
    }

    fn run_interrupt(&mut self) -> bool {
        if !self.interrupt_pending { return false; }
        let status = self.status.bits() ^ 0x20;
        self.push_stack(status);
        let addr_bytes = self.pc.to_le_bytes();
        self.push_stack(addr_bytes[1]);
        self.push_stack(addr_bytes[0]);
        let addr = if self.maskable_interrupt { 0xFFFE } else { 0xFFFA };
        let addr_lo = self.read_bus(addr);
        let addr_hi = self.read_bus(addr + 1);
        self.pc = bytes_to_addr(addr_lo, addr_hi);
        true
    }

    // Statics
    /// Create a new CPU, connected to the given databus.
    ///
    /// # Note
    ///
    /// Default values are the NES power-up vals
    /// cf. http://wiki.nesdev.com/w/index.php/CPU_power_up_state
    pub fn new(bus: Rc<RefCell<T>>) -> Cpu6502<T> {
        Cpu6502 {
            acc: 0,
            x: 0,
            y: 0,
            stack: 0xFD,
            pc: 0xC000,
            // IRQ disabled
            // Unwrapping b/c this is a constant and should be OK
            status: Status::from_bits(0x24).unwrap(),

            // internal state
            bus,
            cycles: 0,
            tot_cycles: 7,
            instruction: 0xEA,
            addr: 0,
            addr_mode: AddressingMode::Impl,
            instr: Instruction::NOP,
            interrupt_pending: false,
            maskable_interrupt: false,
        }
    }
}

impl<T: Bus> fmt::Display for Cpu6502<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let bytes = self.instruction.to_le_bytes();
        let ops = match self.addr_mode {
            AddressingMode::Abs
            | AddressingMode::AbsX
            | AddressingMode::AbsY
            | AddressingMode::AbsInd => format!("{:02X} {:02X} {:02X}", bytes[0], bytes[1], bytes[2]),
            AddressingMode::Accum | AddressingMode::Impl => format!("{:8<2X}", bytes[0]),
            _ => format!("{:02X} {:02X}   ", bytes[0], bytes[1]),
        };

        let operand_bytes = bytes_to_addr(bytes[1], bytes[2]);
        let bus = self.bus.borrow();
        let data = bus.read(self.addr);
        let addr = self.addr;
        let instr = match self.addr_mode {
            AddressingMode::Abs => format!("{:3?} ${:04X}", self.instr, addr),
            AddressingMode::AbsX => format!("{:3?} ${:04X},X @ {:04X} = {:02X}", self.instr, operand_bytes, addr, data),
            AddressingMode::AbsY => format!("{:3?} ${:04X},Y @ {:04X} = {:02X}", self.instr, operand_bytes, addr, data),
            AddressingMode::AbsInd => format!("{:3?} (${:04X}) = {:04X}", self.instr, operand_bytes, addr),
            AddressingMode::Imm => format!("{:3?} #${:02X}", self.instr, bytes[1]),
            AddressingMode::ZP => format!("{:3?} ${:02X} = {:02X}", self.instr, bytes[1], data),
            AddressingMode::ZPX => format!("{:3?} ${:02X},X @ {:02X} = {:02X}", self.instr, bytes[1], self.x, addr),
            AddressingMode::ZPY => format!("{:3?} ${:02X},Y @ {:02X} = {:02X}", self.instr, bytes[1], self.y, addr),
            AddressingMode::Impl => format!("{:3?}", self.instr),
            AddressingMode::Rel => format!("{:3?} ${:04X}", self.instr, addr),
            _ => format!("{:3?} {:02X} {:02X} <TODO>", self.instr, bytes[1], bytes[2])
        };
        write!(
            f,
            //PC     Ops   Inst Accum    X reg    Y reg    Status   Stack     PPU.row...line  tot_cycles
            "{:04X}  {:8}  {:32}A:{:02X} X:{:02X} Y:{:02X} P:{:02X} SP:{:02X} PPU:{:>3},{:>3} CYC:{}",
            self.pc,
            ops,
            instr,
            self.acc,
            self.x,
            self.y,
            self.status,
            self.stack,
            0,
            0,
            self.tot_cycles
        )
    }
}

pub mod structs {
    #[derive(Debug, PartialEq)]
    pub enum AddressingMode {
        /// Zero-Page
        ZP,
        /// Zero-Page Indexed, X register
        ZPX,
        /// Zero-Page Indexed, Y register
        ZPY,
        /// Absolute Indexed, plus X register
        AbsX,
        /// Absolute Indexed, plus Y register
        AbsY,
        /// Indexed Indirect (d, x)
        IndX,
        /// Indirect Indexed (d), y
        ///
        /// gee thanks MOS what a helpful name
        /// not like there's a significant difference between how (d, x) and (d),y
        /// work
        ///
        /// ...oh wait
        IndY,
        /// Implicit indexing (do nothing, resolve nothing, deny everything)
        Impl,
        /// Use the Accumulator
        Accum,
        /// Don't fetch anything and use the operand as data
        Imm,
        /// Jump to a relative label
        Rel,
        /// Addressing mode specific to JMP
        AbsInd,
        /// The 16 address is included in the operand
        Abs,
    }

    /// Enum for the instructions implemented by this emulator
    ///
    /// *depends on BCD flag, not currently supported
    #[derive(Debug, PartialEq)]
    pub enum Instruction {
        /// ADd with Carry*
        ADC,
        /// bitwise AND w/ acc
        AND,
        /// Arithmetic Shift Left
        ASL,
        /// test BITs
        BIT,

        //region Branch instructions
        /// Branch on PLus
        BPL,
        /// Branch on MInus
        BMI,
        /// Branch on oVerflow Clear
        BVC,
        /// Branch on oVerflow Set
        BVS,
        /// Branch on Carry Clear
        BCC,
        /// Branch on Carry Set
        BCS,
        /// Branch on Not Equal
        BNE,
        /// Branch on EQual
        BEQ,
        //endregion
        /// BReaK
        BRK,
        /// CoMPare acc
        CMP,
        /// ComPare X
        CPX,
        /// ComPare Y
        CPY,
        /// DECrement
        DEC,
        /// bitwise Exclusive OR
        EOR,

        //region Flag instructions
        /// CLear Carry
        CLC,
        /// SEt Carry
        SEC,
        /// CLear Interrupt mask
        CLI,
        /// SEt Interrupt mask
        SEI,
        /// CLear oVerflow
        CLV,
        /// CLear Decimal
        CLD,
        /// SEt Decimal
        SED,
        //endregion
        /// INCrement memory
        INC,
        /// JuMP
        ///
        /// # Note on a major CPU bug
        ///
        /// The 6502 had a serious bug with indirect absolute indexing and the
        /// JMP instruction. If the operand crosses a page boundary, the 6502 will
        /// 'forget' the carry and instead use the 00 byte on that page.
        ///
        /// TODO: Implement that bug
        JMP,
        /// Jump to SubRoutine
        JSR,
        /// LoaD Acc
        LDA,
        /// LoaD X
        LDX,
        /// LoaD Y
        LDY,
        /// Logical Shift Right
        LSR,
        /// No OPeration
        NOP,
        /// bitwise OR with Acc
        ORA,

        //region Register Instructions
        /// Transfer A to X
        TAX,
        /// Transfer X to A
        TXA,
        /// DEcrement X
        DEX,
        /// INcrement X
        INX,
        /// Transfer A to Y
        TAY,
        /// Transfer Y to A
        TYA,
        /// DEcrement Y
        DEY,
        /// INcrement Y
        INY,
        //endregion

        //region Rotation instructions
        // Note: Rotation actually includes the Carry bit in rotation operations. So
        // if you rotate 0b1100_0000 left, and C is not asserted, you will get
        // 0b1000_0000 instead of 0b1000_0001, and Carry will be asserted.
        // Early versions of the 6502 had a bad bug with these instructions, where
        // they would actually work as arithmetic shifts (ignoring Carry). This
        // was fixed long before the NES, and so this emulation doesn't implement
        // that bug.
        /// ROtate Left
        ROL,
        /// ROtate Right
        ROR,
        //endregion

        //region Returns
        /// ReTurn from Interrupt
        RTI,
        /// ReTurn from Subroutine
        RTS,
        //endregion
        /// SuBtract with Carry*
        SBC,

        //region Store instructions
        /// STore Acc
        STA,
        /// STore X
        STX,
        /// STore Y
        STY,
        //endregion

        //region Stack instructions
        /// Transfer X to Stack
        TXS,
        /// Transfer Stack to X
        TSX,
        /// PusH Acc
        PHA,
        /// PuLl Acc
        PLA,
        /// PusH Processor status
        PHP, // or, the dreaded spawn of Rasmus Lerdorf
        /// PuLl Processor status
        PLP,
        //endregion
    }

    bitflags! {
        pub struct Status: u8 {
            const CARRY = 0x01;
            const ZERO = 0x02;
            const IRQ_DISABLE = 0x04;
            const DECIMAL = 0x08;
            const BREAK = 0x10;
            const UNUSED = 0x20;
            const OVERFLOW = 0x40;
            const NEGATIVE = 0x80;
        }
    }
}